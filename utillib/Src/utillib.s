/**
 ******************************************************************************
 * @file           : lib.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Library body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2021 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *
 ******************************************************************************
 */

.syntax				unified
.cpu cortex-m4 @ STM32L432KC

.thumb
.align

.include "../../include/Inc/stm32l432kc.i"
.section .text

	@
	@ Set Sysclk
	@
	@ parameter usage
	@ r0 - Sysclk Clock source	(eg #RCC_CFGR_SW_PLL)
	@
.globl setsysclk
.type setsysclk, %function
setsysclk:
	push	{r4, r5}
	ldr		r4, =RCC_CFGR
	ldr		r5, [r4]
	orr		r5, r0			@ system clock  RCC_CFRG->SW
	str		r5, [r4]
	pop		{r4, r5}

	bx		lr


	@
	@ Enable the HSI16 clock and wait for it to become ready
	@
.globl hsienable
.type hsienable, %function
hsienable:
	ldr		r0, =RCC_CRRCR
	ldr		r1, [r0]					@ Get initial state of rcc_crrc
	orr		r1, #RCC_CRRCR_HSI48ON
	str		r1, [r0]

waithsi48rdy:
	ldr		r1, [r0]
	tst		r1, #RCC_CRRCR_HSI48RDY
	beq		waithsi48rdy

	@ Enable HSI
	ldr		r0, =RCC_CR
	ldr		r1, [r0]			@ Get initial state of rcc_cr
	orr		r1, #RCC_CR_HSION
	str		r1, [r0]

waithsirdy:
	ldr		r1, [r0]
	tst		r1, #RCC_CR_HSIRDY
	beq		waithsirdy

	bx		lr


	@
	@ PLL Enable - Set PLL as system clock at 80Mhz
	@
.globl pllenable
.type pllenable, %function
pllenable:
	@ Introduce some wait states to flash accesses otherwise the system becomes unstable
	ldr		r0, =FLASH_ACR
	ldr		r1, [r0]
	bic		r1, #FLASH_ACR_LATENCY
	orr		r1, #FLASH_ACR_LATENCY_4
	str		r1, [r0]

	@ Configure the PLL.   PLL Frequency = (PLL Src clock / PLLM) * PLLN / PLLR
	ldr		r0, =RCC_PLLCFGR
	ldr		r1, [r0]					@ Get initial state of RCC_PLLCFGR
	orr		r1, #RCC_PLLCFGR_PLLSRC_HSI16
	orr		r1, #0x07 << 27				@ PLLPDIV => 7
	orr		r1, #RCC_PLLCFGR_PLLP_7		@ PLLP => 0
	orr		r1, #RCC_PLLCFGR_PLLREN
	orr		r1, #RCC_PLLCFGR_PLLQ_2
	bic		r1, #RCC_PLLCFGR_PLLN		@ Clear all PLLN bits

	@ freq = (clk / PLLM) * PLLN / PLLR
	orr		r1, #RCC_PLLCFGR_PLLM_1				@ PLLM => 0 (PLL Src clock / PLLM)
	orr		r1, #(10 << RCC_PLLCFGR_PLLN_Pos)	@ PLLN
	orr		r1, #RCC_PLLCFGR_PLLR_2

	str		r1, [r0]

	@
	@ Enable PLL
	@
	ldr		r0, =RCC_CR
	ldr		r1, [r0]					@ Get initial state of rcc_cr
	orr		r1, #RCC_CR_PLLON
	str		r1, [r0]

 waitpllrdy:
	ldr		r1, [r0]
	tst		r1, #RCC_CR_PLLRDY
	beq		waitpllrdy

	bx		lr
	.pool


	@
	@ Set MCO
	@
	@ parameter usage
	@ r0 - MCO Clock source	(eg #RCC_CFGR_MCOSEL_SYSCLK)
	@ r1 - MCO Prescalar	(eg #RCC_CFGR_MCOPRE_16)
	@
.globl setMCO
.type setMCO, %function
setMCO:
	push	{r4, r5}
	ldr		r4, =RCC_CFGR
	ldr		r5, [r4]
	orr		r5, r1						@ Select MCO prescaler

	bic		r5, #RCC_CFGR_MCOSEL		@ CLear MSO Selection bits
	orr		r5, r0						@ Set MCO clock

	str		r5, [r4]
	pop		{r4, r5}
	bx		lr

@ r0 points to a string
.globl usart1write
.type usart1write, %function
usart1write:
u1waittxe:
	push	{r3, r4, r5}

u1uwloop:
	ldrb	r5, [r0], #1
	cmp		r5, #0
	beq		u1endwrite

	ldr		r3, =USART2_ISR
	ldr		r4, [r3]
	tst		r4, #USART2_ISR_TXE
	beq		u1waittxe

	ldr		r3, =USART1_TDR
	mov		r4, r5
	and		r4, #0xff
	str		r4, [r3]

u1waittc:
	ldr		r3, =USART1_ISR
	ldr		r4, [r3]
	tst		r4, #USART1_ISR_TC
	beq		u1waittc

	ldr		r3, =USART1_ICR
	ldr		r4, [r3]
	orr		r4, #USART1_ISR_TCCF
	str		r4, [r3]
	b		u1uwloop

u1endwrite:
	pop		{r3, r4, r5}
	bx		lr

@ r0 points to a string
.globl usart2write
.type usart2write, %function
usart2write:
	push	{r3, r4, r5}

u2uwloop:
	ldrb	r5, [r0], #1
	cmp		r5, #0
	beq		u2endwrite

u2waittxe:
	ldr		r3, =USART2_ISR
	ldr		r4, [r3]
	tst		r4, #USART2_ISR_TXE
	beq		u2waittxe

	ldr		r3, =USART2_TDR
	mov		r4, r5
	and		r4, #0xff
	str		r4, [r3]

u2waittc:
	ldr		r3, =USART2_ISR
	ldr		r4, [r3]
	tst		r4, #USART2_ISR_TC
	beq		u2waittc

	ldr		r3, =USART2_ICR
	ldr		r4, [r3]
	orr		r4, #USART2_ISR_TCCF
	str		r4, [r3]
	b		u2uwloop

u2endwrite:
	pop		{r3, r4, r5}
	bx		lr

@
@ Enable USART1
@
.globl uart1enable
.type uart1enable, %function
uart1enable:
	@ Enable clock to USART1
	ldr		r0, =RCC_APB2ENR
	ldr		r1, [r0]
	orr		r1, #RCC_APB2ENR_USART1EN
	str		r1, [r0]

	@ RCC_CCIPR->USART1CSEL
	LDR		R0, =RCC_CCIPR
	LDR		R1, [R0]
	ORR		R1, #RCC_CCIPR_USART1SEL		@ Select System Clock as USART1 CLock Clock
	STR		R1, [R0]

	@ Disable USART1
	ldr		r0, =USART1_CR1
	ldr		r1, [r0]
	bic		r1, #USART1_CR1_UE
	str		r1, [r0]

	@ Set STOP Bits 00 - n Stop bits
	ldr		r0, =USART1_CR1
	ldr		r1, [r0]
	bic		r1, #USART1_CR1_M0			@ M0:M1 00 - 1 start, 8 data, n stop bits
	bic		r1, #USART1_CR1_M1
	bic		r1, #USART1_CR1_OVER8		@ oversampling by 16
	str		r1, [r0]

	@ Set data length 8 bits
	ldr		r0, =USART1_CR2
	ldr		r1, [r0]
	bic		r1, #USART1_CR2_STOP		@ 1 Stop bit
	str		r1, [r0]

	@ Set baud rate 9600
	ldr		r0, =USART1_BRR
	ldr		r1, [r0]
	mov		r1, #0x208D
	str		r1, [r0]

	@ enable transmit and receive
	ldr		r0, =USART1_CR1
	ldr		r1, [r0]
	orr		r1, #USART1_CR1_TE			@ Transmit enable
	orr		r1, #USART1_CR1_RE			@ Receive enable
	str		r1, [r0]

	@ enable USART
	ldr		r0, =USART1_CR1
	ldr		r1, [r0]
	orr		r1, #USART1_CR1_UE
	str		r1, [r0]

u1waittxrdy:
	ldr		r0, =USART1_ISR
	ldr		r1, [r0]
	tst		r1, #USART1_ISR_TEACK
	beq		u1waittxrdy

u1waitrxrdy:
	ldr		r0, =USART1_ISR
	ldr		r1, [r0]
	tst		r1, #USART1_ISR_REACK
	beq		u1waitrxrdy

	bx		lr

@
@ Enable USART2
@
.globl uart2enable
.type uart2enable, %function
uart2enable:
	@ Enable clock to USART2
	ldr		r0, =RCC_APB1ENR
	ldr		r1, [r0]
	orr		r1, #RCC_APB1ENR1_USART2EN
	str		r1, [r0]

	@ RCC_CCIPR->USART2CSEL
	LDR		R0, =RCC_CCIPR
	LDR		R1, [R0]
	ORR		R1, #RCC_CCIPR_USART2SEL		@ Select System Clock as USART2 CLock Clock
	STR		R1, [R0]

	@ Disable USART2
	ldr		r0, =USART2_CR1
	ldr		r1, [r0]
	bic		r1, #USART2_CR1_UE
	str		r1, [r0]

	@ Set STOP Bits 00 - n Stop bits
	ldr		r0, =USART2_CR1
	ldr		r1, [r0]
	bic		r1, #USART2_CR1_M0			@ M0:M1 00 - 1 start, 8 data, n stop bits
	bic		r1, #USART2_CR1_M1
	bic		r1, #USART2_CR1_OVER8		@ oversampling by 16
	str		r1, [r0]

	@ Set data length 8 bits
	ldr		r0, =USART2_CR2
	ldr		r1, [r0]
	bic		r1, #USART2_CR2_STOP		@ 1 Stop bit
	str		r1, [r0]

	@ Set baud rate 9600
	ldr		r0, =USART2_BRR
	ldr		r1, [r0]
	mov		r1, #0x208D
	str		r1, [r0]

	@ enable transmit and receive
	ldr		r0, =USART2_CR1
	ldr		r1, [r0]
	orr		r1, #USART2_CR1_TE			@ Transmit enable
	orr		r1, #USART2_CR1_RE			@ Receive enable
	str		r1, [r0]

	@ enable USART
	ldr		r0, =USART2_CR1
	ldr		r1, [r0]
	orr		r1, #USART2_CR1_UE
	str		r1, [r0]

u2waittxrdy:
	ldr		r0, =USART2_ISR
	ldr		r1, [r0]
	tst		r1, #USART2_ISR_TEACK
	beq		u2waittxrdy

u2waitrxrdy:
	ldr		r0, =USART2_ISR
	ldr		r1, [r0]
	tst		r1, #USART2_ISR_REACK
	beq		u2waitrxrdy

	bx		lr


	@
	@ Initialize GPIOa - Alternate function 7 -> Set pa2 to usart2 tx, pa3 to usart2 rx
	@ This connects USART2 to the stlink tx and rx and allows serial comms down the stlink connection
	@
.globl setGPIOA_USART2
.type setGPIOA_USART2, %function
setGPIOA_USART2:
	@ Enable clock to GPIOA
	ldr		r0, =RCC_AHB2ENR
	ldr		r1, [r0]
	orr		r1, #RCC_AHB2ENR_GPIOA_EN
	str		r1, [r0]

	@ Set Alternate function 7 for GPIOA PA2 (USART2_TX)
	ldr		r0, =GPIOA_AFRL
	ldr		r1, [r0]
	bic		r1, #GPIOx_AFRL_AFSEL2
	orr		r1, #GPIOx_AFRL_AFSEL2_AF7

	@ Set Alternate function 7 for GPIOA PA3 (USART2_RX)
	bic		r1, #GPIOx_AFRL_AFSEL3
	orr		r1, #GPIOx_AFRL_AFSEL3_AF7

	str		r1, [r0]

	@ Set GPIOA Ports into Alternate function mode
	ldr		r0, =GPIOA_MODER
	ldr		r1, [r0]

	bic		r1, #GPIOx_MODER_P3				// Clear moder
	orr		r1, #GPIOx_MODER_P3_Altfn		// pa3 - Alternate function 7 USART2_RX

	bic		r1, #GPIOx_MODER_P2				// Clear moder
	orr		r1, #GPIOx_MODER_P2_Altfn		// pa2 - Alternate function 7 USART2_TX

	str		r1, [r0]

	bx		lr
	.pool

	@
	@ Initialize GPIOa - Alternate function 7 -> Set pa2 to usart2 tx, pa3 to usart2 rx
	@
.globl setGPIOA_USART1
.type setGPIOA_USART1, %function
setGPIOA_USART1:
	@ Enable clock to GPIOA
	ldr		r0, =RCC_AHB2ENR
	ldr		r1, [r0]
	orr		r1, #RCC_AHB2ENR_GPIOA_EN
	str		r1, [r0]

	@ Set Alternate function 7 for GPIOA PA9 (USART1_TX)
	ldr		r0, =GPIOA_AFRL
	ldr		r1, [r0]
	bic		r1, #GPIOx_AFRH_AFSEL9
	orr		r1, #GPIOx_AFRH_AFSEL9_AF7

	@ Set Alternate function 7 for GPIOA PA10 (USART1_RX)
	bic		r1, #GPIOx_AFRH_AFSEL10
	orr		r1, #GPIOx_AFRH_AFSEL10_AF7

	str		r1, [r0]

	@ Set GPIOA Ports into Alternate function mode
	ldr		r0, =GPIOA_MODER
	ldr		r1, [r0]

	bic		r1, #GPIOx_MODER_P9				// Clear moder
	orr		r1, #GPIOx_MODER_P9_Altfn		// pa9 - Alternate function 7 USART1_RX

	bic		r1, #GPIOx_MODER_P10				// Clear moder
	orr		r1, #GPIOx_MODER_P10_Altfn		// pa10 - Alternate function 7 USART1_TX

	str		r1, [r0]

	bx		lr
	.pool

	@
	@ toggle the green user led (led3)
	@
.globl toggle_led3
.type toggle_led3, %function
toggle_led3:
	ldr		r1, =GPIOB_ODR
	ldr		r2, [r1]
	tst		r2, #LED_ON
	bne		Turn_OFF
Turn_ON:
	orr		r0, #LED_ON
	b		Done
Turn_OFF:
	bic		r0, #LED_ON
Done:
	str		r0, [r1]
skip:
	bx		lr


@
@ Initialize GPIOA - Alternate function 0 on pa8 which sets MCO to output on pa8
@
.globl setMCO_to_pa8
.type setMCO_to_pa8, %function
setMCO_to_pa8:
	@ Enable clock to GPIOA
	ldr		r0, =RCC_AHB2ENR
	ldr		r1, [r0]
	orr		r1, #RCC_AHB2ENR_GPIOA_EN
	str		r1, [r0]

	@ Set Alternate function 0 for GPIOA PA8 - Selects MCO on pa8
	ldr		r0, =GPIOA_AFRH
	ldr		r1, [r0]
	bic		r1, #GPIOx_AFRH_AFSEL8
	orr		r1, #GPIOx_AFRH_AFSEL8_AF0		// AF Mode 0 = MCO out on pa8
	str		r1, [r0]

	@ Set GPIOA Port 8 into Alternate function mode
	ldr		r0, =GPIOA_MODER
	ldr		r1, [r0]
	bic		r1, #GPIOx_MODER_P8				// Clear moder
	orr		r1, #GPIOx_MODER_P8_Altfn		// pa8 - bit 17 set => Alternate function mode
	str		r1, [r0]

	bx		lr



//
// Simple delay, r0 = lsw of delay r1 = msw of delay
//
.globl simple_delay
.type simple_delay, %function
simple_delay:
	push	{r4-r7, lr}
dlyup:
	cbz		r0, exdlyup
	sub		r0, #1
	b		dlyup
exdlyup:
	pop    {r4-r7, pc}



//*********** DisableInterrupts ***************
// disable interrupts
// inputs:  none
// outputs: none
.globl DisableInterrupts
.type DisableInterrupts, %function
DisableInterrupts:
	cpsid  i      // set I=1
	bx     lr

//*********** EnableInterrupts ***************
// enable interrupts
// inputs:  none
// outputs: none
EnableInterrupts:
.globl EnableInterrupts
.type EnableInterrupts, %function
   cpsie	i     // set I=0
   bx		lr

//*********** WaitForInterrupt ************************
// go to low power mode while waiting for the next interrupt
// inputs:  none
// outputs: none
WaitForInterrupt:
.globl WaitForInterrupt
.type WaitForInterrupt, %function
	wfi
	bx		lr
